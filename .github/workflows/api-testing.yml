name: API Testing

on:
  push:
    branches:
      - user-service
      - microservices-refactor
      - main
      # - dev-environ-node-gateway
      - integration-gateway-pong-front
      - log-service
      - upstream_timeouts
    # No paths restriction for push - always run when pushing to these branches
  pull_request:
    branches:
      - microservices-refactor
      - main
    paths:
      - 'transcendence/services/**'
      - 'transcendence/shared/**'
      - 'transcendence/docker-compose.yml'
      - '.github/workflows/api-testing.yml'

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Check if services exist
        run: |
          echo "üîç Checking service structure..."
          ls -la transcendence/services/
          
          if [ -d "transcendence/services/user-service" ]; then
            echo "‚úÖ User service directory exists"
            ls -la transcendence/services/user-service/
          else
            echo "‚ùå User service directory not found"
            exit 1
          fi

      - name: Install User Service dependencies
        run: |
          cd transcendence/services/user-service
          if [ -f package.json ]; then
            echo "üì¶ Installing user-service dependencies..."
            npm install
          else
            echo "‚ùå package.json not found in user-service"
            exit 1
          fi

      - name: Install Shared dependencies
        run: |
          cd transcendence/shared
          if [ -f package.json ]; then
            echo "üì¶ Installing shared dependencies..."
            npm install
          else
            echo "üì¶ Creating shared package.json and installing sqlite3..."
            npm init -y
            npm install sqlite3
          fi

      - name: Validate User Service code
        run: |
          cd transcendence/services/user-service
          echo "üß™ Validating user service structure..."
          
          # Check if main files exist
          if [ -f src/index.js ]; then
            echo "‚úÖ Main server file exists"
          else
            echo "‚ùå src/index.js not found"
            exit 1
          fi
          
          # Basic syntax check without running the server
          echo "üîç Checking Node.js syntax..."
          node -c src/index.js && echo "‚úÖ Syntax validation passed" || {
            echo "‚ùå Syntax errors found"
            exit 1
          }
          
          # Check package.json scripts
          if grep -q '"start"' package.json; then
            echo "‚úÖ Start script found"
          else
            echo "‚ö†Ô∏è No start script found in package.json"
          fi

  api-integration-tests:
    runs-on: ubuntu-latest
    needs: unit-tests
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Generate SSL certificates for HTTPS testing
        run: |
          cd transcendence
          echo "üîê Generating SSL certificates for testing..."
          
          # Ensure script is executable
          chmod +x generate-ssl.sh
          
          # Run SSL generation with verbose output
          echo "Running generate-ssl.sh..."
          if ./generate-ssl.sh; then
            echo "‚úÖ SSL generation script completed successfully"
          else
            echo "‚ùå SSL generation script failed with exit code: $?"
            echo "Script contents:"
            cat generate-ssl.sh
            exit 1
          fi
          
      - name: Create test environment file
        run: |
          cd transcendence
          cat > .env << EOF
          NODE_ENV=test
          DATABASE_URL=sqlite:/app/shared/database/transcendence.db
          JWT_SECRET=test-jwt-secret-key-not-for-production-use-only
          
          # Frontend URLs (Browser ‚Üí nginx ‚Üí gateway) - HTTPS for production testing
          VITE_API_BASE=https://localhost/api
          VITE_GATEWAY_BASE=https://localhost/api
          VITE_WS_BASE=wss://localhost/ws
          FRONT_END_URL=https://localhost
          
          # Backend URLs (Docker internal network)
          USER_SERVICE_URL=http://user-service:3001
          GAME_SERVICE_URL=http://game-service:3002
          LOG_SERVICE_URL=http://log-service:3003
          TOURNAMENT_SERVICE_URL=http://tournament-service:3005
          GATEWAY_URL=http://gateway:3000
          EOF
          
          echo "‚úÖ Test environment file created"

      - name: Validate SSL certificate generation
        run: |
          cd transcendence
          echo "ÔøΩ Checking SSL certificate generation..."
          
          # Check if SSL directory exists
          if [ -d "nginx/ssl" ]; then
            echo "‚úÖ SSL directory exists"
            ls -la nginx/ssl/
            
            # Check if certificates were generated
            if [ -f "nginx/ssl/certificate.crt" ] && [ -f "nginx/ssl/private.key" ]; then
              echo "‚úÖ SSL certificates found"
              
              # Validate certificate
              echo "üìã Certificate details:"
              openssl x509 -in nginx/ssl/certificate.crt -text -noout | head -20
              
              # Check certificate validity and show details
              if openssl x509 -in nginx/ssl/certificate.crt -checkend 0 > /dev/null; then
                echo "‚úÖ Certificate is valid"
                echo "Certificate subject:"
                openssl x509 -in nginx/ssl/certificate.crt -subject -noout
                echo "Certificate dates:"
                openssl x509 -in nginx/ssl/certificate.crt -dates -noout
              else
                echo "‚ùå Certificate is invalid or expired"
                openssl x509 -in nginx/ssl/certificate.crt -dates -noout || echo "Cannot read certificate dates"
                exit 1
              fi
              
              # Check private key
              if openssl rsa -in nginx/ssl/private.key -check > /dev/null 2>&1; then
                echo "‚úÖ Private key is valid"
              else
                echo "‚ùå Private key is invalid"
                exit 1
              fi
              
              # Verify certificate and key match
              CERT_MODULUS=$(openssl x509 -noout -modulus -in nginx/ssl/certificate.crt | openssl md5)
              KEY_MODULUS=$(openssl rsa -noout -modulus -in nginx/ssl/private.key | openssl md5)
              
              if [ "$CERT_MODULUS" = "$KEY_MODULUS" ]; then
                echo "‚úÖ Certificate and private key match"
              else
                echo "‚ùå Certificate and private key do not match"
                echo "Certificate modulus: $CERT_MODULUS"
                echo "Key modulus: $KEY_MODULUS"
                exit 1
              fi
              
              # Test if nginx can use these certificates
              echo "üß™ Testing nginx SSL configuration..."
              echo "server {
                listen 9999 ssl;
                ssl_certificate /tmp/test.crt;
                ssl_certificate_key /tmp/test.key;
                location / { return 200 'SSL test OK'; }
              }" > /tmp/nginx_ssl_test.conf
              
              cp nginx/ssl/certificate.crt /tmp/test.crt
              cp nginx/ssl/private.key /tmp/test.key
              
              if nginx -t -c /tmp/nginx_ssl_test.conf > /dev/null 2>&1; then
                echo "‚úÖ nginx can use the SSL certificates"
              else
                echo "‚ö†Ô∏è nginx SSL test failed (may be expected in CI environment)"
                nginx -t -c /tmp/nginx_ssl_test.conf || true
              fi
              
              # Cleanup test files
              rm -f /tmp/nginx_ssl_test.conf /tmp/test.crt /tmp/test.key
              
            else
              echo "‚ùå SSL certificates not found"
              echo "Expected files:"
              echo "  - nginx/ssl/certificate.crt"
              echo "  - nginx/ssl/private.key"
              echo "Actual contents:"
              find nginx/ssl -type f || echo "No files found"
              exit 1
            fi
          else
            echo "‚ùå SSL directory does not exist"
            echo "Directory structure:"
            ls -la nginx/
            exit 1
          fi

      - name: Validate Docker Compose configuration
        run: |
          cd transcendence
          echo "üîç Validating docker-compose.yml..."
          docker compose config > /dev/null
          echo "‚úÖ Docker Compose configuration is valid"
          
          echo "üîí Checking service port exposure..."
          
          # Check that only gateway port is exposed
          if grep -A 5 "gateway:" docker-compose.yml | grep -E "ports:|3000:3000"; then
            echo "‚úÖ Gateway port 3000 is properly exposed"
          else
            echo "‚ö†Ô∏è Gateway port might not be exposed correctly"
          fi
          
          # Check that user-service port is NOT exposed
          if grep -A 10 "user-service:" docker-compose.yml | grep -E "ports:" | grep -E "3001"; then
            echo "‚ùå User-service port is exposed - this should NOT happen!"
            exit 1
          else
            echo "‚úÖ User-service port is correctly NOT exposed"
          fi
          
          # Check that game-service port is NOT exposed
          if grep -A 10 "game-service:" docker-compose.yml | grep -E "ports:" | grep -E "3002"; then
            echo "‚ùå Game-service port is exposed - this should NOT happen!"
            exit 1
          else
            echo "‚úÖ Game-service port is correctly NOT exposed"
          fi
          
          # Check that log-service port is NOT exposed
          if grep -A 10 "log-service:" docker-compose.yml | grep -E "ports:" | grep -E "3003"; then
            echo "‚ùå Log-service port is exposed - this should NOT happen!"
            exit 1
          else
            echo "‚úÖ Log-service port is correctly NOT exposed"
          fi

      - name: Build and start services
        run: |
          cd transcendence
          echo "üöÄ Building and starting services for API testing..."
          
          # First check if we need to modify nginx healthcheck for HTTPS
          echo "Checking nginx healthcheck configuration..."
          grep -A 5 "healthcheck:" docker-compose.yml | grep -A 3 "nginx" || echo "nginx healthcheck not found"
          
          # Start services with nginx proxy for full HTTPS architecture testing
          docker compose up -d --build database user-service gateway nginx
          
          echo "‚è≥ Waiting for services to initialize..."
          sleep 30
          
          # Check initial container status
          echo "Initial container status:"
          docker compose ps
          
          # Wait additional time for services to fully start
          echo "Giving services more time to fully initialize..."
          sleep 60
          
          # Verify SSL certificates are accessible in nginx container
          echo "üîç Verifying SSL certificates in nginx container..."
          if docker compose exec -T nginx ls -la /etc/nginx/ssl/; then
            echo "‚úÖ SSL directory accessible in nginx container"
            docker compose exec -T nginx ls -la /etc/nginx/ssl/
          else
            echo "‚ùå Cannot access SSL directory in nginx container"
            exit 1
          fi

      - name: Check container status
        run: |
          cd transcendence
          echo "üìä Checking container status..."
          docker compose ps
          
          echo "üìã Checking user-service logs..."
          docker compose logs user-service | tail -20

      - name: Wait for Services to be ready
        run: |
          cd transcendence
          echo "üîç Checking services health..."
          
          # First check if containers are running
          if ! docker compose ps user-service | grep -Eq "running|healthy|Up"; then
            echo "‚ùå User service container is not running"
            docker compose logs user-service
            exit 1
          fi
          
          if ! docker compose ps gateway | grep -Eq "running|healthy|Up"; then
            echo "‚ùå Gateway container is not running"
            docker compose logs gateway
            exit 1
          fi
          
          if ! docker compose ps nginx | grep -Eq "running|healthy|Up"; then
            echo "‚ùå nginx container is not running"
            docker compose logs nginx
            exit 1
          fi
          
          # Wait for the user service to be ready (internal network)
          echo "üì° Testing User Service internal health check..."
          
          for i in {1..15}; do
            # Method 1: Try docker compose exec (most reliable) - works inside the container
            if docker compose exec -T user-service wget -qO- http://localhost:3001/health > /dev/null 2>&1; then
              echo "‚úÖ User Service is ready and responding internally (exec method)"
              break
            # Method 2: Check if user-service container is actually running and healthy
            elif docker compose ps user-service | grep -q "running\|Up"; then
              echo "Container is running, trying network connection..."
              # Get the actual network name dynamically
              USER_CONTAINER_ID=$(docker compose ps -q user-service | head -1)
              if [ ! -z "$USER_CONTAINER_ID" ]; then
                ACTUAL_NETWORK=$(docker inspect "$USER_CONTAINER_ID" --format '{{range $k, $v := .NetworkSettings.Networks}}{{$k}}{{end}}' 2>/dev/null | head -1)
                echo "Detected network: $ACTUAL_NETWORK"
                if [ ! -z "$ACTUAL_NETWORK" ] && docker run --rm --network "$ACTUAL_NETWORK" curlimages/curl:latest curl -f -s http://user-service:3001/health > /dev/null 2>&1; then
                  echo "‚úÖ User Service is ready and responding internally (network: $ACTUAL_NETWORK)"
                  break
                fi
              fi
            fi
            
            echo "‚è≥ Waiting for User Service... attempt $i/15"
            sleep 10
            if [ $i -eq 15 ]; then
              echo "‚ùå User Service failed to respond after 150 seconds"
              echo "=== Container Status ==="
              docker compose ps
              echo "=== Network Info ==="
              docker network ls
              echo "=== User Service Container Details ==="
              USER_CONTAINER_ID=$(docker compose ps -q user-service | head -1)
              if [ ! -z "$USER_CONTAINER_ID" ]; then
                echo "Container ID: $USER_CONTAINER_ID"
                docker inspect "$USER_CONTAINER_ID" --format '{{range $k, $v := .NetworkSettings.Networks}}Network: {{$k}}, IP: {{$v.IPAddress}}{{"\n"}}{{end}}' 2>/dev/null || echo "Could not inspect container networks"
              fi
              echo "=== User Service Logs ==="
              docker compose logs user-service
              exit 1
            fi
          done
          
          # Wait for HTTPS services to be ready
          echo "üîí Waiting for HTTPS nginx + Gateway to be ready..."
          
          # First, check if containers are running
          echo "Checking container status..."
          docker compose ps
          
          # Wait specifically for HTTPS to work
          for i in {1..20}; do
            echo "‚è≥ HTTPS health check attempt $i/20..."
            
            # Test HTTPS with detailed output
            HTTPS_TEST=$(curl -k -s --connect-timeout 10 --max-time 15 \
              -w "HTTP_CODE:%{http_code} TIME:%{time_total}" \
              -o /tmp/health_check.json \
              https://localhost/api/health 2>&1)
            
            if echo "$HTTPS_TEST" | grep -q "HTTP_CODE:200"; then
              echo "‚úÖ HTTPS nginx + Gateway is ready and responding"
              echo "Response time: $(echo "$HTTPS_TEST" | grep -o 'TIME:[0-9.]*')"
              echo "‚è≥ Giving services additional time to fully initialize..."
              sleep 15
              break
            else
              echo "   HTTPS failed: $HTTPS_TEST"
              
              # Parse curl error for specific issues
              if echo "$HTTPS_TEST" | grep -q "Connection refused"; then
                echo "   Issue: Connection refused - nginx not accepting connections on 443"
              elif echo "$HTTPS_TEST" | grep -q "SSL"; then
                echo "   Issue: SSL/TLS related problem"
              elif echo "$HTTPS_TEST" | grep -q "timeout"; then
                echo "   Issue: Connection timeout"
              elif echo "$HTTPS_TEST" | grep -q "certificate"; then
                echo "   Issue: Certificate related problem"
              fi
              
              # Detailed debugging every 5th attempt
              if [ $((i % 5)) -eq 0 ]; then
                echo "   === Detailed diagnosis (attempt $i) ==="
                
                # Check containers
                if ! docker compose ps nginx | grep -E "running|Up" > /dev/null; then
                  echo "   ‚ùå nginx container is not running"
                  docker compose logs nginx | tail -5
                else
                  echo "   ‚úÖ nginx container is running"
                fi
                
                if ! docker compose ps gateway | grep -E "running|Up" > /dev/null; then
                  echo "   ‚ùå gateway container is not running"
                  docker compose logs gateway | tail -5
                else
                  echo "   ‚úÖ gateway container is running"
                fi
                
                # Check SSL certificates in container
                echo "   Checking SSL setup..."
                docker compose exec -T nginx ls -la /etc/nginx/ssl/ 2>/dev/null || echo "   Cannot access SSL directory"
                
                # Check if nginx is listening on port 443
                docker compose exec -T nginx netstat -tln 2>/dev/null | grep :443 || echo "   nginx not listening on 443"
                
                # Check nginx process
                docker compose exec -T nginx ps aux | grep nginx || echo "   nginx process not found"
                
                # Test nginx configuration
                docker compose exec -T nginx nginx -t || echo "   nginx configuration test failed"
                
                # Check if SSL files are readable by nginx
                docker compose exec -T nginx test -r /etc/nginx/ssl/certificate.crt && echo "   Certificate is readable" || echo "   Certificate is NOT readable"
                docker compose exec -T nginx test -r /etc/nginx/ssl/private.key && echo "   Private key is readable" || echo "   Private key is NOT readable"
                
                # Check gateway health directly
                GATEWAY_DIRECT=$(docker compose exec -T gateway curl -f -s --connect-timeout 5 http://localhost:3000/health 2>/dev/null && echo "OK" || echo "FAIL")
                echo "   Gateway internal health: $GATEWAY_DIRECT"
              fi
              
              if [ $i -eq 20 ]; then
                echo "‚ùå HTTPS failed to work after 20 attempts (300 seconds)"
                echo "=== Final diagnosis ==="
                echo "Container status:"
                docker compose ps
                echo "nginx logs (last 30 lines):"
                docker compose logs nginx | tail -30
                echo "Gateway logs (last 30 lines):"
                docker compose logs gateway | tail -30
                echo "Port mappings:"
                docker compose port nginx 443 || echo "No port 443 mapping"
                echo "SSL files:"
                docker compose exec -T nginx find /etc/nginx/ssl -type f -ls 2>/dev/null || echo "Cannot list SSL files"
                
                echo "Final curl debugging - testing specific SSL issues:"
                # Test with verbose curl to see exact SSL error
                curl -k -v --connect-timeout 10 --max-time 15 https://localhost/api/health 2>&1 | head -30
                
                echo "Testing if curl exit code 60 is related to SSL:"
                # curl exit code 60 = SSL_CACERT: Peer certificate cannot be authenticated with known CA certificates
                echo "This suggests an SSL certificate validation issue"
                exit 1
              fi
              
              echo "   Waiting 15 seconds before retry..."
              sleep 15
            fi
          done

      - name: Install testing tools
        run: |
          sudo apt-get update
          sudo apt-get install -y curl jq

      - name: Test Health Check Endpoints
        run: |
          cd transcendence
          echo "üß™ Testing Health Check Endpoints..."
          
          # Use HTTPS endpoint (production setup)
          echo "ÔøΩ Using HTTPS endpoints for testing..."
          BASE_URL="https://localhost/api"
          CURL_FLAGS="-k"
          
          # Verify HTTPS is working before proceeding
          echo "Verifying HTTPS connectivity..."
          if ! curl -k -f -s --connect-timeout 15 --max-time 30 https://localhost/api/health > /dev/null 2>&1; then
            echo "‚ùå HTTPS endpoint is not responding"
            echo "This indicates a problem with the SSL setup or nginx configuration"
            
            echo "=== SSL/nginx Diagnosis ==="
            echo "nginx container status:"
            docker compose ps nginx
            
            echo "nginx logs (last 20 lines):"
            docker compose logs nginx | tail -20
            
            echo "SSL files in nginx container:"
            docker compose exec -T nginx ls -la /etc/nginx/ssl/ || echo "Cannot access SSL directory"
            
            echo "Port mappings:"
            docker compose port nginx 443 || echo "Port 443 not mapped"
            
            exit 1
          fi
          
          echo "‚úÖ HTTPS endpoint verified"
          echo "Selected BASE_URL: $BASE_URL"
          
          # Additional SSL connectivity test
          echo "üîê Testing SSL connectivity details..."
          echo | openssl s_client -connect localhost:443 -servername localhost 2>/dev/null | head -10
          
          # Test certificate chain
          echo "üìã SSL Certificate information:"
          echo | openssl s_client -connect localhost:443 -servername localhost 2>/dev/null | openssl x509 -noout -subject -issuer -dates
          
          # Test Gateway Health Check (via nginx)
          echo "1. üåê Testing Gateway Health Check (via nginx)"
          GATEWAY_HEALTH=$(curl $CURL_FLAGS -s -w "%{http_code}" -o /tmp/gateway_health.json \
            --connect-timeout 15 --max-time 30 $BASE_URL/health)
          if [ "$GATEWAY_HEALTH" = "200" ]; then
            echo "‚úÖ Gateway health check passed"
            cat /tmp/gateway_health.json | jq .
          else
            echo "‚ùå Gateway health check failed with status: $GATEWAY_HEALTH"
            exit 1
          fi
          
          # Test User Service Health Check through nginx ‚Üí Gateway
          echo "2. üè• Testing User Service Health Check (via nginx ‚Üí Gateway)"
          USER_VIA_GATEWAY=$(curl $CURL_FLAGS -s -w "%{http_code}" -o /tmp/user_via_gateway.json \
            --connect-timeout 15 --max-time 30 $BASE_URL/user-service/health)
          if [ "$USER_VIA_GATEWAY" = "200" ]; then
            echo "‚úÖ User Service health check via nginx ‚Üí Gateway passed"
            cat /tmp/user_via_gateway.json | jq .
          else
            echo "‚ùå User Service health check via nginx ‚Üí Gateway failed with status: $USER_VIA_GATEWAY"
            exit 1
          fi
          
          # Test User Service Health Check directly (internal network only - should NOT be accessible from host)
          echo "3. üîí Verifying User Service is NOT directly accessible from host"
          if curl -s --connect-timeout 5 http://localhost:3001/health > /dev/null 2>&1; then
            echo "‚ùå User Service is directly accessible - this should NOT happen!"
            echo "‚ùå Port 3001 should not be exposed in docker-compose.yml"
            exit 1
          else
            echo "‚úÖ User Service is properly isolated - not accessible directly from host"
          fi
          
          # Test User Service Health Check directly via internal network (using docker)
          echo "4. üîç Testing User Service Health Check (internal network)"
          
          # Try exec method first (most reliable)
          if docker compose exec -T user-service wget -qO- http://localhost:3001/health > /tmp/internal_health.json 2>/dev/null; then
            echo "‚úÖ User Service health check (internal exec) passed"
            cat /tmp/internal_health.json
          else
            # Fallback: try with default network name
            INTERNAL_HEALTH=$(docker run --rm --network transcendence_default curlimages/curl:latest curl -s -w "%{http_code}" -o /dev/stdout http://user-service:3001/health 2>/dev/null | tail -c 3)
            if [ "$INTERNAL_HEALTH" = "200" ]; then
              echo "‚úÖ User Service health check (internal network) passed"
              # Get the actual response body
              docker run --rm --network transcendence_default curlimages/curl:latest curl -s http://user-service:3001/health 2>/dev/null
            else
              # Try to detect actual network and use it
              CONTAINER_NETWORK=$(docker compose ps -q user-service | head -1 | xargs docker inspect --format '{{range $k, $v := .NetworkSettings.Networks}}{{$k}}{{end}}' 2>/dev/null || echo "")
              if [ ! -z "$CONTAINER_NETWORK" ]; then
                echo "Trying detected network: $CONTAINER_NETWORK"
                INTERNAL_HEALTH=$(docker run --rm --network "$CONTAINER_NETWORK" curlimages/curl:latest curl -s -w "%{http_code}" -o /dev/stdout http://user-service:3001/health 2>/dev/null | tail -c 3)
                if [ "$INTERNAL_HEALTH" = "200" ]; then
                  echo "‚úÖ User Service health check (detected network) passed"
                  docker run --rm --network "$CONTAINER_NETWORK" curlimages/curl:latest curl -s http://user-service:3001/health 2>/dev/null
                else
                  echo "‚ùå User Service health check (internal) failed with status: $INTERNAL_HEALTH"
                  echo "Tried networks: transcendence_default, $CONTAINER_NETWORK"
                  echo "Available networks:"
                  docker network ls
                  exit 1
                fi
              else
                echo "‚ùå Could not detect container network and default failed"
                exit 1
              fi
            fi
          fi

      - name: Test User Service Endpoints via Gateway
        run: |
          cd transcendence
          echo "üß™ Running User Service API tests via nginx ‚Üí Gateway..."
          
          # Test HTTPS endpoint (should work in production setup)
          echo "ÔøΩ Testing HTTPS endpoint..."
          
          # First test with detailed curl output to see what's failing
          echo "Detailed HTTPS test:"
          HTTPS_RESPONSE=$(curl -k -v -s --connect-timeout 15 --max-time 30 \
            -w "HTTP_CODE:%{http_code} TOTAL_TIME:%{time_total} SSL_VERIFY_RESULT:%{ssl_verify_result}" \
            -o /tmp/https_test.json \
            https://localhost/api/health 2>&1)
          
          echo "HTTPS Response: $HTTPS_RESPONSE"
          
          if echo "$HTTPS_RESPONSE" | grep -q "HTTP_CODE:200"; then
            GATEWAY_URL="https://localhost/api"
            CURL_FLAGS="-k"
            echo "‚úÖ HTTPS is working correctly"
            echo "Selected base URL: $GATEWAY_URL"
          else
            echo "‚ùå HTTPS is not working properly"
            echo "Full curl output:"
            echo "$HTTPS_RESPONSE"
            
            echo "=== Debugging HTTPS issues ==="
            echo "1. Checking if SSL certificates exist in container:"
            docker compose exec -T nginx ls -la /etc/nginx/ssl/ || echo "Cannot access nginx container"
            
            echo "2. Checking nginx SSL configuration:"
            docker compose exec -T nginx nginx -t || echo "nginx config test failed"
            
            echo "3. Checking nginx error logs:"
            docker compose logs nginx | grep -i error | tail -10
            
            echo "4. Testing direct connection to nginx HTTPS port:"
            docker compose port nginx 443 || echo "Port 443 not exposed"
            
            echo "5. Checking if nginx is listening on 443:"
            docker compose exec -T nginx netstat -tln | grep :443 || echo "nginx not listening on 443"
            
            echo "6. Testing HTTP (should redirect to HTTPS):"
            HTTP_TEST=$(curl -v -s --connect-timeout 10 --max-time 20 \
              -w "HTTP_CODE:%{http_code}" \
              -o /tmp/http_test.json \
              http://localhost/api/health 2>&1)
            echo "HTTP test result: $HTTP_TEST"
            
            # This should fail because we want HTTPS to work
            exit 1
          fi
          
          # User Registration via Gateway
          echo "1. üë§ Testing User Registration (via Gateway)"
          UNIQUE_ID=$(date +%s)
          REGISTER_PAYLOAD='{
            "username": "testuser'$UNIQUE_ID'",
            "email": "test'$UNIQUE_ID'@example.com",
            "password": "SecurePassword123!"
          }'
          
          REGISTER_RESPONSE=$(curl $CURL_FLAGS -s -w "%{http_code}" -o /tmp/register.json \
            --connect-timeout 30 --max-time 60 \
            -X POST $GATEWAY_URL/auth/register \
            -H "Content-Type: application/json" \
            -d "$REGISTER_PAYLOAD")
          
          if [ "$REGISTER_RESPONSE" = "201" ]; then
            echo "‚úÖ User registration via Gateway passed"
            cat /tmp/register.json | jq .
          else
            echo "‚ùå User registration via Gateway failed with status: $REGISTER_RESPONSE"
            cat /tmp/register.json
            exit 1
          fi
          
          # Extract token from registration
          TOKEN=$(cat /tmp/register.json | jq -r '.token // empty')
          
          # User Login via Gateway (test with same credentials)
          echo "2. üîê Testing User Login (via Gateway)"
          LOGIN_PAYLOAD='{
            "email": "test'$UNIQUE_ID'@example.com",
            "password": "SecurePassword123!"
          }'
          
          LOGIN_RESPONSE=$(curl $CURL_FLAGS -s -w "%{http_code}" -o /tmp/login.json \
            --connect-timeout 30 --max-time 60 \
            -X POST $GATEWAY_URL/auth/login \
            -H "Content-Type: application/json" \
            -d "$LOGIN_PAYLOAD")
          
          if [ "$LOGIN_RESPONSE" = "200" ]; then
            echo "‚úÖ User login via Gateway passed"
            cat /tmp/login.json | jq .
            # Use login token if registration token wasn't available
            if [ -z "$TOKEN" ]; then
              TOKEN=$(cat /tmp/login.json | jq -r '.token // empty')
            fi
          else
            echo "‚ùå User login via Gateway failed with status: $LOGIN_RESPONSE"
            cat /tmp/login.json
            exit 1
          fi
          
          # Profile Access via Gateway (Protected Route)
          echo "3. üë• Testing Protected Profile Endpoint (via Gateway)"
          if [ ! -z "$TOKEN" ]; then
            PROFILE_RESPONSE=$(curl $CURL_FLAGS -s -w "%{http_code}" -o /tmp/profile.json \
              --connect-timeout 30 --max-time 60 \
              -X GET $GATEWAY_URL/auth/profile \
              -H "Authorization: Bearer $TOKEN")
            
            if [ "$PROFILE_RESPONSE" = "200" ]; then
              echo "‚úÖ Profile access via Gateway passed"
              cat /tmp/profile.json | jq .
            else
              echo "‚ùå Profile access via Gateway failed with status: $PROFILE_RESPONSE"
              cat /tmp/profile.json
              exit 1
            fi
          else
            echo "‚ö†Ô∏è No token available, skipping profile test"
          fi
          
          # Verify direct access to user service endpoints is blocked
          echo "4. üîí Testing User Service isolation"
          
          # Test if port 3001 is exposed (should not be in production)
          echo "Checking if user-service port 3001 is exposed..."
          
          # First, check if we can connect to port 3001
          if timeout 5 bash -c "</dev/tcp/localhost/3001" 2>/dev/null; then
            echo "‚ö†Ô∏è Warning: Port 3001 is accessible from host"
            echo "This might be expected in CI/test environment, but should NOT happen in production"
            echo "Verifying docker-compose.yml doesn't expose user-service port..."
            
            # Check docker-compose.yml to ensure user-service port is not exposed
            if grep -A 10 "user-service:" transcendence/docker-compose.yml | grep -E "ports:|3001:3001"; then
              echo "‚ùå docker-compose.yml exposes user-service port - this should be fixed!"
              echo "Current docker-compose.yml user-service configuration:"
              grep -A 15 "user-service:" transcendence/docker-compose.yml
              exit 1
            else
              echo "‚úÖ docker-compose.yml correctly does NOT expose user-service port"
              echo "Port accessibility might be due to CI environment network configuration"
            fi
          else
            echo "‚úÖ User Service port 3001 is properly isolated from host"
          fi
          
          # Additional test: Verify that going through gateway works correctly
          echo "5. üåê Verifying complete Gateway functionality"
          
          # Test a complete user journey through the gateway
          echo "Testing complete user workflow via Gateway only..."
          
          JOURNEY_ID=$(date +%s)_journey
          JOURNEY_PAYLOAD='{
            "username": "journey'$JOURNEY_ID'",
            "email": "journey'$JOURNEY_ID'@example.com",
            "password": "JourneyPassword123!"
          }'
          
          # Register via Gateway with timeout and better error handling
          echo "Attempting registration via Gateway..."
          set +e  # Don't exit on error for this test
          JOURNEY_REGISTER=$(curl $CURL_FLAGS -s -w "%{http_code}" -o /tmp/journey_register.json \
            --connect-timeout 30 --max-time 60 \
            -X POST $GATEWAY_URL/user-service/auth/register \
            -H "Content-Type: application/json" \
            -d "$JOURNEY_PAYLOAD" 2>/dev/null)
          CURL_EXIT_CODE=$?
          set -e  # Re-enable exit on error
          
          echo "CURL exit code: $CURL_EXIT_CODE"
          echo "HTTP status code: $JOURNEY_REGISTER"
          
          # Specific handling for curl exit code 60
          if [ $CURL_EXIT_CODE -eq 60 ]; then
            echo "‚ùå CURL EXIT CODE 60 DETECTED!"
            echo "This typically means: SSL certificate problem: unable to get local issuer certificate"
            echo "Testing SSL connection details..."
            
            # Test SSL connection with more details
            echo "=== SSL Connection Test ==="
            openssl s_client -connect localhost:443 -servername localhost -verify_return_error < /dev/null 2>&1 | head -20
            
            echo "=== Certificate chain test ==="
            echo | openssl s_client -connect localhost:443 -servername localhost 2>/dev/null | openssl x509 -noout -subject -issuer
            
            exit 1
          fi
          
          if [ $CURL_EXIT_CODE -eq 0 ] && [ "$JOURNEY_REGISTER" = "201" ]; then
            echo "‚úÖ Registration via Gateway successful"
            cat /tmp/journey_register.json
            
            # Login via Gateway
            LOGIN_JOURNEY_PAYLOAD='{
              "email": "journey'$JOURNEY_ID'@example.com",
              "password": "JourneyPassword123!"
            }'
            
            echo "Attempting login via Gateway..."
            set +e
            JOURNEY_LOGIN=$(curl $CURL_FLAGS -s -w "%{http_code}" -o /tmp/journey_login.json \
              --connect-timeout 30 --max-time 60 \
              -X POST $GATEWAY_URL/user-service/auth/login \
              -H "Content-Type: application/json" \
              -d "$LOGIN_JOURNEY_PAYLOAD" 2>/dev/null)
            CURL_EXIT_CODE=$?
            set -e
            
            echo "Login CURL exit code: $CURL_EXIT_CODE"
            echo "Login HTTP status code: $JOURNEY_LOGIN"
            
            if [ $CURL_EXIT_CODE -eq 0 ] && [ "$JOURNEY_LOGIN" = "200" ]; then
              echo "‚úÖ Complete user journey via Gateway successful"
              cat /tmp/journey_login.json
              
              # Extract token and test profile
              JOURNEY_TOKEN=$(cat /tmp/journey_login.json | jq -r '.token // empty' 2>/dev/null || echo "")
              if [ ! -z "$JOURNEY_TOKEN" ]; then
                echo "Testing profile access..."
                set +e
                JOURNEY_PROFILE=$(curl $CURL_FLAGS -s -w "%{http_code}" -o /tmp/journey_profile.json \
                  --connect-timeout 30 --max-time 60 \
                  -X GET $GATEWAY_URL/user-service/auth/profile \
                  -H "Authorization: Bearer $JOURNEY_TOKEN" 2>/dev/null)
                CURL_EXIT_CODE=$?
                set -e
                
                if [ $CURL_EXIT_CODE -eq 0 ] && [ "$JOURNEY_PROFILE" = "200" ]; then
                  echo "‚úÖ Profile access via Gateway successful"
                else
                  echo "‚ö†Ô∏è Profile access failed: HTTP=$JOURNEY_PROFILE, CURL_EXIT=$CURL_EXIT_CODE"
                fi
              else
                echo "‚ö†Ô∏è No token received from login"
              fi
            else
              echo "‚ö†Ô∏è Login via Gateway failed: HTTP=$JOURNEY_LOGIN, CURL_EXIT=$CURL_EXIT_CODE"
              if [ -f /tmp/journey_login.json ]; then
                echo "Login response:"
                cat /tmp/journey_login.json
              fi
            fi
          else
            echo "‚ö†Ô∏è Registration via Gateway failed: HTTP=$JOURNEY_REGISTER, CURL_EXIT=$CURL_EXIT_CODE"
            if [ -f /tmp/journey_register.json ]; then
              echo "Registration response:"
              cat /tmp/journey_register.json
            fi
            # Show service logs for debugging
            echo "=== Gateway logs (last 20 lines) ==="
            docker compose logs gateway | tail -20
            echo "=== User Service logs (last 20 lines) ==="
            docker compose logs user-service | tail -20
          fi
          
          echo "üéâ All Gateway API tests passed!"

      - name: Test Invalid Requests via Gateway
        run: |
          echo "üß™ Testing error handling and validation via Gateway..."
          
          GATEWAY_URL="http://localhost:3000"
          
          # Test registration with missing fields via Gateway
          echo "1. Testing registration with missing fields (via Gateway)"
          echo "Sending payload: {\"username\": \"test\"}"
          INVALID_REGISTER=$(curl -s -w "%{http_code}" -o /tmp/invalid_register.json \
            -X POST $GATEWAY_URL/user-service/auth/register \
            -H "Content-Type: application/json" \
            -d '{"username": "test"}')
          
          echo "Response body:"
          cat /tmp/invalid_register.json
          echo ""
          echo "HTTP Status Code: $INVALID_REGISTER"
          
          if [ "$INVALID_REGISTER" = "400" ]; then
            echo "‚úÖ Validation error handled correctly via Gateway"
          else
            echo "‚ùå Expected 400 but got: $INVALID_REGISTER"
            echo "Debugging info:"
            echo "Length of response: ${#INVALID_REGISTER}"
            echo "Response as hex: $(echo -n "$INVALID_REGISTER" | xxd)"
          fi
          
          # Test login with wrong credentials via Gateway
          echo "2. Testing login with invalid credentials (via Gateway)"
          echo "Sending payload: {\"email\": \"nonexistent@test.com\", \"password\": \"wrong\"}"
          INVALID_LOGIN=$(curl -s -w "%{http_code}" -o /tmp/invalid_login.json \
            -X POST $GATEWAY_URL/user-service/auth/login \
            -H "Content-Type: application/json" \
            -d '{"email": "nonexistent@test.com", "password": "wrong"}')
          
          echo "Response body:"
          cat /tmp/invalid_login.json
          echo ""
          echo "HTTP Status Code: $INVALID_LOGIN"
          
          if [ "$INVALID_LOGIN" = "401" ]; then
            echo "‚úÖ Invalid credentials handled correctly via Gateway"
          else
            echo "‚ùå Expected 401 but got: $INVALID_LOGIN"
          fi
          
          # Test protected route without token via Gateway
          echo "3. Testing protected route without token (via Gateway)"
          NO_TOKEN_RESPONSE=$(curl -s -w "%{http_code}" -o /tmp/no_token.json \
            -X GET $GATEWAY_URL/user-service/auth/profile)
          
          if [ "$NO_TOKEN_RESPONSE" = "401" ]; then
            echo "‚úÖ Missing token handled correctly via Gateway"
          else
            echo "‚ùå Expected 401 but got: $NO_TOKEN_RESPONSE"
          fi
          
          # Test protected route with invalid token via Gateway
          echo "4. Testing protected route with invalid token (via Gateway)"
          INVALID_TOKEN_RESPONSE=$(curl -s -w "%{http_code}" -o /tmp/invalid_token.json \
            -X GET $GATEWAY_URL/user-service/auth/profile \
            -H "Authorization: Bearer invalid-token")
          
          if [ "$INVALID_TOKEN_RESPONSE" = "403" ]; then
            echo "‚úÖ Invalid token handled correctly via Gateway"
          else
            echo "‚ùå Expected 403 but got: $INVALID_TOKEN_RESPONSE"
          fi
          
          echo "‚úÖ All error handling tests passed!"

      - name: Test Database Operations via Gateway
        run: |
          echo "üóÑÔ∏è Testing database operations via Gateway..."
          
          # Check if database was created and has data
          docker compose exec -T user-service ls -la /app/shared/database/ || echo "Database directory check"
          
          # Test duplicate user registration via Gateway
          echo "Testing duplicate user registration via Gateway"
          GATEWAY_URL="http://localhost:3000"
          
          DUPLICATE_PAYLOAD='{
            "username": "duplicate_test",
            "email": "duplicate@test.com",
            "password": "password123"
          }'
          
          # First registration via Gateway
          curl -s -X POST $GATEWAY_URL/user-service/auth/register \
            -H "Content-Type: application/json" \
            -d "$DUPLICATE_PAYLOAD" > /dev/null
          
          # Second registration (should fail) via Gateway
          DUPLICATE_RESPONSE=$(curl -s -w "%{http_code}" -o /tmp/duplicate.json \
            -X POST $GATEWAY_URL/user-service/auth/register \
            -H "Content-Type: application/json" \
            -d "$DUPLICATE_PAYLOAD")
          
          if [ "$DUPLICATE_RESPONSE" = "409" ]; then
            echo "‚úÖ Duplicate user prevention works via Gateway"
          else
            echo "‚ö†Ô∏è Duplicate user response: $DUPLICATE_RESPONSE"
            cat /tmp/duplicate.json
          fi

      - name: Performance Testing via Gateway
        run: |
          echo "‚ö° Running basic performance tests via Gateway..."
          
          GATEWAY_URL="http://localhost:3000"
          
          # Test multiple concurrent health checks via Gateway
          echo "Testing concurrent Gateway health check requests..."
          for i in {1..10}; do
            curl -s $GATEWAY_URL/health > /dev/null &
          done
          wait
          echo "‚úÖ Concurrent Gateway requests handled"
          
          # Test multiple concurrent User Service health checks via Gateway
          echo "Testing concurrent User Service health check requests via Gateway..."
          for i in {1..10}; do
            curl -s $GATEWAY_URL/user-service/health > /dev/null &
          done
          wait
          echo "‚úÖ Concurrent User Service requests via Gateway handled"
          
          # Test Gateway response time
          echo "Testing Gateway response time..."
          START_TIME=$(date +%s%N)
          curl -s $GATEWAY_URL/health > /dev/null
          END_TIME=$(date +%s%N)
          RESPONSE_TIME=$(( (END_TIME - START_TIME) / 1000000 ))
          echo "Gateway response time: ${RESPONSE_TIME}ms"
          
          if [ $RESPONSE_TIME -lt 1000 ]; then
            echo "‚úÖ Gateway response time is acceptable (< 1000ms)"
          else
            echo "‚ö†Ô∏è Gateway response time is high: ${RESPONSE_TIME}ms"
          fi
          
          # Test User Service via Gateway response time
          echo "Testing User Service via Gateway response time..."
          START_TIME=$(date +%s%N)
          curl -s $GATEWAY_URL/user-service/health > /dev/null
          END_TIME=$(date +%s%N)
          RESPONSE_TIME=$(( (END_TIME - START_TIME) / 1000000 ))
          echo "User Service via Gateway response time: ${RESPONSE_TIME}ms"
          
          if [ $RESPONSE_TIME -lt 2000 ]; then
            echo "‚úÖ User Service via Gateway response time is acceptable (< 2000ms)"
          else
            echo "‚ö†Ô∏è User Service via Gateway response time is high: ${RESPONSE_TIME}ms"
          fi

      - name: Show service logs on failure
        if: failure()
        run: |
          cd transcendence
          echo "=== Gateway Logs ==="
          docker compose logs gateway | tail -100
          echo "=== User Service Logs ==="
          docker compose logs user-service | tail -100

      - name: Cleanup
        if: always()
        run: |
          cd transcendence
          docker compose down -v
          docker system prune -f

  security-tests:
    runs-on: ubuntu-latest
    needs: [api-integration-tests]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Security scan with npm audit
        run: |
          cd transcendence/services/user-service
          npm audit --audit-level=high || echo "‚ö†Ô∏è Security vulnerabilities found"

      - name: Check for hardcoded secrets
        run: |
          echo "üîç Scanning for potential security issues..."
          
          # Check for hardcoded passwords/secrets (exclude test files)
          if grep -r -i "password.*=" transcendence/services/user-service/src/ | grep -v test | grep -v example; then
            echo "‚ö†Ô∏è Potential hardcoded passwords found"
          else
            echo "‚úÖ No hardcoded passwords detected"
          fi
          
          # Check for exposed API keys
          if grep -r -E "(api[_-]?key|secret[_-]?key)" transcendence/services/user-service/src/ | grep -v test | grep -v example; then
            echo "‚ö†Ô∏è Potential API keys found in source"
          else
            echo "‚úÖ No exposed API keys detected"
          fi

  load-tests:
    runs-on: ubuntu-latest
    needs: [api-integration-tests]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Start services for load testing
        run: |
          cd transcendence
          docker compose up -d --build database user-service gateway
          sleep 30

      - name: Install Apache Bench
        run: |
          sudo apt-get update
          sudo apt-get install -y apache2-utils

      - name: Run load tests
        run: |
          echo "üöÄ Running load tests via Gateway..."
          
          # Test Gateway health endpoint with 100 requests, 10 concurrent
          echo "Testing Gateway health endpoint..."
          ab -n 100 -c 10 http://localhost:3000/health
          
          # Test User Service health via Gateway with 50 requests, 5 concurrent
          echo "Testing User Service health via Gateway..."
          ab -n 50 -c 5 http://localhost:3000/user-service/health
          
          echo "‚úÖ Load tests completed"

      - name: Cleanup load test
        if: always()
        run: |
          cd transcendence
          docker compose down -v

  api-documentation-test:
    runs-on: ubuntu-latest
    needs: unit-tests
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check API documentation
        run: |
          echo "üìö Checking API documentation..."
          
          # Check if there's API documentation
          if [ -f transcendence/docs/api-contracts.md ]; then
            echo "‚úÖ API documentation found"
            
            # Check if documentation mentions the endpoints we're testing
            if grep -q "/auth/register\|/auth/login\|/auth/profile" transcendence/docs/api-contracts.md; then
              echo "‚úÖ API endpoints documented"
            else
              echo "‚ö†Ô∏è API endpoints not fully documented"
            fi
          else
            echo "‚ö†Ô∏è API documentation missing"
          fi

  final-api-status:
    runs-on: ubuntu-latest
    needs: [unit-tests, api-integration-tests, api-documentation-test]
    if: always()
    
    steps:
      - name: Report API test results
        run: |
          echo "=== API Testing Results ==="
          
          if [ "${{ needs.unit-tests.result }}" = "success" ]; then
            echo "‚úÖ Unit tests passed"
          else
            echo "‚ùå Unit tests failed"
          fi
          
          if [ "${{ needs.api-integration-tests.result }}" = "success" ]; then
            echo "‚úÖ API integration tests passed"
          else
            echo "‚ùå API integration tests failed"
          fi
          
          echo "‚ÑπÔ∏è Security tests run separately"
          
          if [ "${{ needs.api-documentation-test.result }}" = "success" ]; then
            echo "‚úÖ Documentation check passed"
          else
            echo "‚ùå Documentation check failed"
          fi
          
          # Only fail if critical tests failed
          if [ "${{ needs.unit-tests.result }}" != "success" ] || \
             [ "${{ needs.api-integration-tests.result }}" != "success" ]; then
            echo "‚ùå Critical API tests failed"
            exit 1
          fi
          
          echo "üéâ API testing pipeline completed successfully!"